#!/usr/bin/env python3

import argparse
import json
import os
import re
import shutil
import subprocess
import sys

# Globals
verbose = False

# Utility
def cmd(args):
	if verbose:
		sys.stderr.write('cmd "{}"\n'.format(' '.join(args)))
	subprocess.run(args, check=True)

def cmd_output(args):
	if verbose:
		sys.stderr.write('cmd "{}"\n'.format(' '.join(args)))
	return subprocess.run(args, check=True, encoding='utf-8', stdout=subprocess.PIPE).stdout

# Default params value
default_emulator = os.path.join(os.path.abspath(os.path.dirname(sys.argv[0])), '../../emulator/emulator')
default_template_dir = os.path.abspath(os.path.dirname(sys.argv[0]))
default_working_dir = '/tmp/c65_bench'

# Params from environement
da65 = os.getenv('DA65_BIN', 'da65')
clang = os.getenv('CLANG_MOS', 'clang-mos')
emulator = os.getenv('EMU65', default_emulator)

# Params from commandline
parser = argparse.ArgumentParser(description='Bench input code, compiled by 6502-gcc')
parser.add_argument('sources', metavar='N', type=str, nargs='+', help='Files to compile')
parser.add_argument('--options', '-O', type=str, default='', help='Compilation options')
parser.add_argument('--template-dir', '-t', type=str, default=default_template_dir, help='Directory containing reference files')
parser.add_argument('--working-dir', '-w', type=str, default=default_working_dir, help='Directory in which the bench is built')
parser.add_argument('--verbose', '-v', action='store_true', help='print compiler commands issued on stderr')
args = parser.parse_args()

source_list = [os.path.abspath(p) if p != '-' else '-' for p in args.sources]
compil_options = args.options.split(' ') if args.options != '' else []
template_dir = os.path.abspath(args.template_dir)
working_dir = os.path.abspath(args.working_dir)
verbose = args.verbose

# Setup working directory
shutil.copytree(template_dir, working_dir)
os.chdir(working_dir)

# Build bench
built_prg_path = os.path.join(working_dir, 'bench.6502')

for i in range(len(source_list)):
	source_path = source_list[i]
	if source_path == '-':
		source_contents = sys.stdin.read()
		source_path = os.path.join(working_dir, 'stdin.c')
		with open(source_path, 'w') as source_file:
			source_file.write(source_contents)
		source_list[i] = source_path

cmd([clang, '--config', 'config/bench.cfg', '-o', built_prg_path] + compil_options + ['bench.c'] + source_list)

#######################
# Extract generated asm
#######################

#TODO we could compile independently each file with "-S" and without "-flto" (remove it from config file) to obtain their generated assembly
#     note that we should still compile to benched result with "-flto" and disasemble it, to see the effect of LTO

striped_prg = '{}.strip'.format(built_prg_path)

#subprocess.run(f'head -c -6 "{built_prg_path}" > "{striped_prg}"', check=True, shell=True) # remove two dummy bytes, and initialization vectors
#TODO actually do the above manipulation in python instead of bash, allowing to: remove trailing null bytes, retrieve code size, avoid poorly readable sheel invocation

# Read generated prg-rom
built_prg = None
with open(built_prg_path, 'rb') as built_prg_file:
	built_prg = built_prg_file.read();

# Remove vectors and trailing zeros
index = -7
while built_prg[index] == 0:
	index -= 1
built_prg = built_prg[:index+1]

# Save resulting stripped file
with open(striped_prg, 'wb') as striped_prg_file:
	striped_prg_file.write(built_prg)

# Disasemble stripped prg
raw_asm = cmd_output([da65, '-S', str(0x8000), striped_prg]).replace('        brk\n', '')
generated_asm = [
	{
		'source': '',
		'asm': raw_asm
	}
]

# Extract code size info
code_size = len(built_prg)

###########
# Run bench
###########

run_process = subprocess.run([emulator, built_prg_path], capture_output=True, check=True, universal_newlines=True)
sys.stderr.write(run_process.stderr)
run_report_out = run_process.stdout
run_report = json.loads(run_report_out)

# Output bench result
print(json.dumps({
	'code_size': code_size,
	'cycle_count': run_report['cycle_count'],
	'ram': run_report['ram'],
	'asm': generated_asm
}))
